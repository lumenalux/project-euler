"""
Each new term in the Fibonacci sequence is generated by adding
the previous two terms. By starting with 1 and 2, the first 10
terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values
do not exceed four million, find the sum of the even-valued terms.

link: https://projecteuler.net/problem=2

Solution:

f_2n+1 = f_2n + f_2n-2 + ... + f_6 + f_4 + f_2 + f_1, f_1 = 1
f_2n+1 = f_2n + f_2n-2 + ... + f_6 + f_4 + f_2 + 1
f_2n+1 - 1 = f_2n + f_2n-2 + ... + f_6 + f_4 + f_2

So sum of even-valued terms is f_2n+1 - 1

Let's efficiently calculate the f_2n+1 using efficient power of
matrix and then find the sum of even-valued terms
"""


def multiply_2x2_matrices(m1, m2):
    a = m1[0][0] * m2[0][0] + m1[0][1] * m2[1][0]
    b = m1[0][0] * m2[0][1] + m1[0][1] * m2[1][1]
    c = m1[1][0] * m2[0][0] + m1[1][1] * m2[1][0]
    d = m1[1][0] * m2[0][1] + m1[1][1] * m2[1][1]

    return [[a, b],
            [c, d]]


def power_2x2_matrix(matrix, n):
    if n <= 1:
        return matrix

    squared_matrix = multiply_2x2_matrices(matrix, matrix)

    if n % 2 == 0:
        return power_2x2_matrix(squared_matrix, n // 2)

    return multiply_2x2_matrices(matrix,
                                 power_2x2_matrix(squared_matrix, (n-1) // 2))


def get_nth_of_fibonacci(n):
    return n if n < 1 else power_2x2_matrix([[1, 1],
                                             [1, 0]], n - 1)[0][0]


# O(log(n)*log(n)) - find the largest _2n such that f_2n < N
#                    binary search log(n) times each time
#                    find the nth fibonacci by O(log(n))
# O(log(n)) - find the sum of even-valued terms
# O(log(n)*log(n)) + O(log(n)) = O(log(n)*log(n)) - total
def solution(N):
    # find the largest _2n such that f_2n < N
    low, high = 0, 1
    while get_nth_of_fibonacci(high) <= N:
        low, high = high, high * 2
    while low < high:
        mid = (low + high + 1) // 2
        if get_nth_of_fibonacci(mid) <= N:
            low = mid
        else:
            high = mid - 1

    _2n = low-1 if low % 2 else low
    return get_nth_of_fibonacci(_2n + 1) - 1


# O(n)
def linear_solution(N):
    previous, current, n = 0, 1, 1
    sum_even = 0
    while current <= N:
        if n % 2 == 0:
            sum_even += current
        n += 1
        previous, current = current, previous + current
    return sum_even


# test
if __name__ == '__main__':
    N = 4_000_000
    print(solution(N), linear_solution(N))  # 3524577 3524577

    N = 4 * 10 ** 1000
    print(solution(N))  # 31068776790948109938947426180404819488893050239575...
    print(linear_solution(N))  # 3106877679094810993894742618040481948889305...
