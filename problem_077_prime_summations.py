"""
It is possible to write ten as the sum of primes in exactly five different
ways:

    7 + 3
    5 + 5
    5 + 3 + 2
    3 + 3 + 2 + 2
    2 + 2 + 2 + 2 + 2

What is the first value which can be written as the sum of primes in over five
thousand different ways?

link: https://projecteuler.net/problem=77

Solution:

Solution:

This problem can be approached using a dynamic programming technique similar
to that used for partitioning numbers, but with a focus on prime numbers.
The solution involves the following steps:

  * Generating Primes: First, we generate all prime numbers up to a certain
    limit using the Sieve of Eratosthenes algorithm. This ensures we have a
    list of prime numbers to work with when calculating the sums.

  * Dynamic Programming Array (dp): We initialize a dynamic programming array
    `dp` with a size large enough to cover our target numbers. `dp[0]` is set
    to 1 as a base case, representing the number of ways to write 0 as a sum
    (which is 1, using no numbers).

  * Filling the dp Array: For each prime number generated by the sieve, we
    iterate through the dynamic programming array, updating `dp[i]` for each
    index `i` from the current prime to the limit. The update rule is
    `dp[i] += dp[i - prime]`, which adds the number of ways to write
    `i - prime` as a sum to the number of ways to write `i` as a sum.
    This effectively counts all unique combinations that sum up to `i` using
    the current set of primes.

  * Finding the Target: The final step is to iterate through the `dp` array
    and find the first index (representing the number) that can be written
    as the sum of primes in over five thousand different ways. This is done
    using `dropwhile` from the `itertools` module, which skips elements of
    the array until the condition (`dp[n] < N`, where `N` is 5000) is no
    longer true.

"""
from itertools import dropwhile

LIMIT = 1000


# For more details about the algorithm:
# https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes
def sieve_of_eratosthenes(n: int) -> list[int]:
    """Sieve of Eratosthenes algorithm to find all primes less than n."""
    sieve = [True] * ((n + 1) // 2)
    for i in range(3, int(n**0.5) + 1, 2):
        if sieve[i // 2]:
            start, end, step = i*i // 2, n // 2, i
            sieve[start:end:step] = [False] * ((end - start - 1) // step + 1)

    return [] if n < 3 else [2, *(2*i + 1
                                  for i in range(1, n // 2) if sieve[i])]


def solution(N: int) -> int:
    dp = [0] * LIMIT
    dp[0] = 1
    for prime in sieve_of_eratosthenes(LIMIT):
        for i in range(prime, LIMIT):
            dp[i] += dp[i - prime]
    return next(dropwhile(lambda n: dp[n] < N, range(LIMIT)), None)


if __name__ == '__main__':
    print(solution(5000))  # 71
