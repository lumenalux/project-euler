"""
Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are
all figurate (polygonal) numbers and are generated by the following formulae:

Triangle:     P3,n=n(n+1)/2     1, 3, 6, 10, 15, ...
Square:       P4,n=n^2          1, 4, 9, 16, 25, ...
Pentagonal:   P5,n=n(3n-1)/2    1, 5, 12, 22, 35, ...
Hexagonal:    P6,n=n(2n-1)      1, 6, 15, 28, 45, ...
Heptagonal:   P7,n=n(5n-3)/2    1, 7, 18, 34, 55, ...
Octagonal:    P8,n=n(3n-2)      1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
interesting properties.

    1. The set is cyclic, in that the last two digits of each number is the
       first two digits of the next number (including the last number with the
       first).

    2. Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and
       pentagonal (P5,44=2882), is represented by a different number in the
       set.

    3. This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for which
each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and
octagonal, is represented by a different number in the set.

link: https://projecteuler.net/problem=61

Solution:

Let's create a table with prefixes of all numbers that can be used in the
sequence. For example, if we have a number 8128, we will add it to the table
with the prefix 81. Then we will iterate over all numbers in the table and try
to find the next number in the sequence. At the end we will have a list of
sequences that can be used to solve the problem. The last thing we need to do
is to filter the sequence that ends with suffix and starts with the same
prefix, so that prefix = suffix.
"""
import math


def get_n(a, b, x):
    return math.floor((math.sqrt(b*b + 8*a*x) - b) / (2*a))


def get_number_generator(k):
    a, b = k - 2, 4 - k
    n_first = get_n(a, b, 1000) + 1
    n_last = get_n(a, b, 10000)
    n_last = n_last if n_last * (a*n_last + b) > 19999 else n_last + 1
    return ((n * (a*n + b) // 2, n) for n in range(n_first, n_last))


def next_subsequences(prefix_table, subsequences):
    for subsequence, n_set, k_set in subsequences:
        suffix = str(subsequence[-1])[2:]
        for x, k, n in prefix_table.get(suffix, []):
            if k not in k_set and n not in n_set:
                yield subsequence + [x], n_set.union({n}), k_set.union({k})


def solution():
    prefix_table = {}
    for k in range(3, 9):
        for x, n in get_number_generator(k):
            prefix_table.setdefault(str(x)[:2], []).append((x, k, n))

    sequences = []
    for _, numbers in prefix_table.items():
        for x, k, n in numbers:
            subsequences = [([x], {n}, {k})]
            for _ in range(5):
                subsequences = next_subsequences(prefix_table, subsequences)
            sequences.extend(seq for seq, _, _ in subsequences)

    return sum(next((seq
                     for seq in sequences
                     if str(seq[0])[:2] == str(seq[-1])[2:]), [0]))


# test
if __name__ == '__main__':
    print(solution()) # 28684
