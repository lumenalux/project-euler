"""
The sequence of triangle numbers is generated by adding
the natural numbers. So the 7th triangle number would be

  1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.

The first ten terms would be:

  1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

   1: 1
   3: 1,3
   6: 1,2,3,6
  10: 1,2,5,10
  15: 1,3,5,15
  21: 1,3,7,21
  28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over
five divisors. What is the value of the first triangle number
to have over five hundred divisors?

link: https://projecteuler.net/problem=12

Solution:

We can factorize a number and then calculate the number of
divisors using such formula:

  N = p1^a1 * p2^a2 * ... * pn^an
  d(n) = (a1 + 1) * (a2 + 1) * ... * (an + 1)

where p1, p2, ..., pn are prime factors of N,
and a1, a2, ..., an are the exponents of the prime factors.
link: https://mathschallenge.net/library/number/number_of_divisors

The triangular number N can be expressed as:

    N = n * (n + 1) / 2, where n in an integer.

If n is even, then n + 1 is odd, and vice versa. So n and n + 1 are
coprime, and the number of divisors of N is equal to the product of
the number of divisors of n and n + 1:

      d(N) = d(n / 2) * d(n + 1), where n is even
      d(N) = d(n) * d((n + 1) / 2), where n is odd

So we can iterate over n and calculate the number of divisors of

  n, (n + 1) / 2, where n is even
  n + 1, n / 2, where n is odd

until we find the first triangular number with over 500 divisors.
Then we can calculate the product of such pair to get the result.
"""

import math

from itertools import count
from functools import lru_cache


# For more details about the algorithm:
# https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes
def sieve_of_eratosthenes(n: int) -> list[int]:
    """Sieve of Eratosthenes algorithm to find all primes less than n."""
    sieve = [True] * ((n + 1) // 2)
    for i in range(3, int(n**0.5) + 1, 2):
        if sieve[i // 2]:
            start, end, step = i*i // 2, n // 2, i
            sieve[start:end:step] = [False] * ((end - start - 1) // step + 1)

    return [] if n < 3 else [2, *(2*i + 1
                                  for i in range(1, n // 2) if sieve[i])]


@lru_cache(maxsize=None)
def get_number_of_divisors(n: int) -> int:
    prime_candidates = sieve_of_eratosthenes(int(n**0.5) + 1)
    factors_count = [1] * len(prime_candidates)
    for i, prime in enumerate(prime_candidates):
        while n % prime == 0:
            factors_count[i] += 1
            n //= prime
        if n < 2:
            break

    # Multiply by 2 if n > 2, because n is prime in this case
    # and there is additional prime factor which is n itself.
    return (2 if n > 2 else 1) * math.prod(factors_count)


def solution(N: int) -> int:
    for n in count(2):
        a, b = (n // 2, n + 1) if n % 2 == 0 else (n, (n + 1) // 2)
        if get_number_of_divisors(a) * get_number_of_divisors(b) > N:
            return a * b


# Works faster
def dp_solution(N: int) -> int:
    # Heruistic formula (N // 2)^2 // 2 for upper bound of n
    number_of_divisors = [1] * (max((N // 2)**2 // 2, 100))
    for n in count(2):
        for i in range(n, len(number_of_divisors), n):
            number_of_divisors[i] += 1
        a, b = (n // 2, n - 1) if n % 2 == 0 else (n, (n - 1) // 2)
        if number_of_divisors[a] * number_of_divisors[b] > N:
            return a * b


# test
if __name__ == '__main__':
    print(solution(5))     # 28
    print(solution(500))   # 76576500
    print(solution(1000))  # 842161320

    print(dp_solution(5))     # 28
    print(dp_solution(500))   # 76576500
    print(dp_solution(1000))  # 842161320
